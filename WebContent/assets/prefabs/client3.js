
// -- user code here --

/* --- start generated code --- */

// Generated by  1.5.4 (Phaser v2.6.2)


/**
 * client3
 * @param {Phaser.Game} aGame A reference to the currently running game.
 * @param {Number} aX The x coordinate (in world space) to position the Sprite at.
 * @param {Number} aY The y coordinate (in world space) to position the Sprite at.
 * @param {any} aKey This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
 * @param {any} aFrame If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
 */
function client3(aGame, aX, aY, aKey, aFrame) {
	Phaser.Sprite.call(this, aGame, aX, aY, aKey || 'atlas5', aFrame == undefined || aFrame == null? 'cliente30000' : aFrame);
	this.anchor.set(0.5, 0.5);
	var _anim_walk = this.animations.add('walk', ['cliente30000', 'cliente30001', 'cliente30002', 'cliente30003', 'cliente30004', 'cliente30005', 'cliente30006', 'cliente30007', 'cliente30008', 'cliente30009', 'cliente30010', 'cliente30011', 'cliente30012', 'cliente30013', 'cliente30014', 'cliente30015', 'cliente30016'], 24, true);
	this.animations.add('idle', ['cliente30000'], 60, false);
	_anim_walk.play();
	this.game.physics.arcade.enable(this);
	this.body.setSize(39.0, 50.0, 2.0, 0.0);
	this.body.velocity.x = -90.0;
	
	this.myCreate();
	
}

/** @type Phaser.Sprite */
var client3_proto = Object.create(Phaser.Sprite.prototype);
client3.prototype = client3_proto;
client3.prototype.constructor = client3;

/* --- end generated code --- */
// -- user code here --
client3.prototype.myCreate = function() {
	
	this.collidingStore =  false;
	this.meLargo =  false;
	//this.oldPos = this.parent.children.indexOf(this);
	this.orderTime = null;
	this.orderBG = null;
	this.waitTime = 5-this.game.state.getCurrentState﻿().level;
	if(this.waitTime <= 8){
		this.waitTime = 8;
	}
	console.log('this.waitTime '+ this.waitTime );
	this.velocidadCliente = this.body.velocity.x;
	
	
}
client3.prototype.makeAnOrder = function() {
	
	
	this.orderTime =  this.game.time.create(false);
	
	this.orderTime.start();
	this.body.velocity.x = 0;
	this.animations.play('idle');
	console.log('making an order');
	

	this.orderBG  = new orderItem(this.game, this.world.x, this.world.y);
	this.orderBG.myClientIs = this;
	var bounce=this.game.add.tween(this.orderBG);
	bounce.to({ y: this.orderBG.y-60 }, 500, Phaser.Easing.Bounce.Out);
	bounce.start();
	bounce.onComplete.add(function(){
		this.orderBG.createFlavor();
		this.game.state.getCurrentState﻿().doingOrder =  true;
	}, this);
	
	this.game.add.existing(this.orderBG);
	this.game.state.getCurrentState﻿().fBagDone.currentClient = this;
}

client3.prototype.checkDistance = function() {


}



client3.prototype.update = function() {
	
	if(this.orderTime!=null){
	
		if (this.orderTime.ms/1000 > this.waitTime){
			this.game.state.getCurrentState﻿().ordenFallida(this.orderBG);
			this.orderTime=null;
			this.meLargo =  true;
			
		}
	}

	this.myQueuePosition = this.parent.children.indexOf(this);
	
if(!this.meLargo){
	if(this.oldPos != this.myQueuePosition){
		this.animations.play('walk');
		this.body.velocity.x = this.velocidadCliente;
	}
	
	if(this.myQueuePosition!==0){
	
		if(this.x <= this.parent.children[this.myQueuePosition-1].x+50){
			
			this.body.velocity.x = 0;
			this.animations.play('idle');
			
		}else{
			
			this.animations.play('walk');
			this.body.velocity.x = this.velocidadCliente;
		}	
		
	}else{
		
		this.collidingStore = this.game.physics.arcade.collide(this , this.game.state.getCurrentState﻿().fStore, this.makeAnOrder, null, this);
		if(!this.collidingStore){
			
			//this.body.velocity.x = -10;
			
		}else{
			//this.body.velocity.x = 0;
			this.body.enable = false;
			
		}
	}
	this.oldPos = this.myQueuePosition;
	
		
	}else{
		
		this.animations.play('walk');
		this.body.velocity.x = Math.abs(this.velocidadCliente);
		
		if(this.body.position.x>this.game.width+100){
			console.log('client destroy');
			//this.game.state.getCurrentState﻿().fClientsRemain.text--;
			this.destroy();
			
		}
	//	this.meLargo =  false;
	}
}